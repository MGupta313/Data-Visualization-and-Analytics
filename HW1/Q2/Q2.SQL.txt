-- Setup. DO NOT REMOVE.
.headers on
.separator ','

DROP TABLE IF EXISTS sets;
DROP TABLE IF EXISTS themes;
DROP TABLE IF EXISTS parts;
DROP VIEW IF EXISTS top_level_themes;
DROP VIEW IF EXISTS sets_years;
DROP TABLE IF EXISTS parts_fts;


-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (a.i) Create tables

-- [insert your SQL statement(s) BELOW this line]
CREATE TABLE sets (
set_num TEXT,
name TEXT,
year INTEGER,
theme_id INTEGER,
num_parts INTEGER
);
CREATE TABLE themes (
id INTEGER,
name TEXT,
parent_id INTEGER
);
CREATE TABLE parts (
part_num TEXT,
name TEXT,
part_cat_id INTEGER,
part_material_id INTEGER
);

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.tables
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (a.ii) Import data

-- [insert your SQLite command(s) BELOW this line]
.import data/sets.csv sets
.import data/themes.csv themes
.import data/parts.csv parts

-- [insert your SQLite command(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.headers off
SELECT count(*) FROM sqlite_master WHERE type='table' AND name='sets';
SELECT count(*) FROM sqlite_master WHERE type='table' AND name='parts';
SELECT count(*) FROM sqlite_master WHERE type='table' AND name='themes';
.headers on
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (b) Create indexes

-- [insert your SQL statement(s) BELOW this line]
CREATE INDEX sets_index  on sets(set_num);
CREATE INDEX parts_index on parts(part_num);
CREATE INDEX themes_index on themes(id);

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.indexes
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (c.i) Create the top_level themes VIEW

-- [insert your SQL statement(s) BELOW this line]
create view top_level_themes
as
    select
        themes.id,
        themes.name
	from themes
	where themes.parent_id = "";

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.headers off
PRAGMA table_info(top_level_themes);
.headers on
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (c.ii) count the top level themes in the top_level_themes view.

-- [insert your SQL statement(s) BELOW this line]
select count(*) as count from top_level_themes;

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (d) Finding top level themes with the most sets.

-- [insert your SQL statement(s) BELOW this line]
select t.name as theme, 
count(s.set_num) as num_sets 
from top_level_themes as t 
inner join sets as s on t.id = s.theme_id
group by t.id 
having count(s.set_num) > 25
order by count(s.set_num) desc;


-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (e) Calculate a percentage

-- [insert your SQL statement(s) BELOW this line]
create temp view percentage_top as
SELECT t.name as theme, (count(*)*100.00/(
	select count(s.set_num) 
	FROM top_level_themes t 
	INNER JOIN sets s ON t.id = s.theme_id)) as percentage
FROM top_level_themes as t 
INNER JOIN sets as s ON t.id = s.theme_id
GROUP BY t.id
HAVING percentage >= 5.00
ORDER BY percentage DESC;

select theme, printf("%.2f", percentage) as percentage
from percentage_top;
-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (f) Summarize a sub-theme

-- [insert your SQL statement(s) BELOW this line]

select themes.name as sub_theme, count(set_num) as num_sets from sets
join themes on themes.id = sets.theme_id
where themes.parent_id != ""
group by themes.id
having count(set_num)>5
order by count(set_num) desc, themes.name;


-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (g.i.) Create the sets VIEW

-- [insert your SQL statement(s) BELOW this line]

create view sets_years
as
	select
        	ROWID,
        	year,
        	count(set_num) as sets_count
        	from sets
	        group by year;

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.headers off
PRAGMA table_info(sets_years);
SELECT count(*) FROM sqlite_master WHERE type='table' AND name='sets_years';
.headers on
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (g.ii) Find the running total of sets in the Rebrickable database each year

-- [insert your SQL statement(s) BELOW this line]
select s1.year as year, (
    select sum(sets_count) from sets_years as s2
    where s1.year >= s2.year) as running_total
from sets_years as s1
where s1.year between 1980 and 1989
order by s1.year;

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (h) Create the FTS table and import data.

-- [insert your SQL statement(s) BELOW this line]
CREATE VIRTUAL TABLE parts_fts USING fts3(
part_num TEXT,
name TEXT,
part_cat_id INTEGER,
part_material_id INTEGER
);

.import data/parts.csv parts_fts

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.headers off
PRAGMA table_info(parts_fts);
.headers on
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (h.i) Count the number of unique parts whose name field begins with the prefix ‘mini’.

-- [insert your SQL statement(s) BELOW this line]
select count(distinct part_num) as count_overview from parts_fts where name MATCH '^mini*';

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (h.ii) List the part_num’s of the unique parts that contain the terms ‘minidoll’ and ‘boy’ in the name field with no more than 5 intervening terms.

-- [insert your SQL statement(s) BELOW this line]
select count(distinct part_num) as total_boy_minidoll from parts_fts where name MATCH '"minidoll" NEAR/5 "boy"';

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (h.iii) List the part_num’s of the unique parts that contain the terms ‘minidoll’ and ‘girl’ in the name field with no more than 5 intervening terms.

-- [insert your SQL statement(s) BELOW this line]
select count(distinct part_num) as total_girl_minidoll from parts_fts where name MATCH '"minidoll" NEAR/5 "girl"';

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --